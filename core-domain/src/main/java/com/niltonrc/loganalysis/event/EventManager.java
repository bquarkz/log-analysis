package com.niltonrc.loganalysis.event;

public class EventManager
{
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Constants
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private static final int DEFAULT_EVENT_ALERT_IN_MILLI_SECS = 4;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Special Fields And Injections
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Fields
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private final Entry first;
    private Entry second;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Constructors
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public EventManager( Entry first )
    {
        if( first == null )
        {
            throw new IllegalArgumentException( "the first entry should not be null" );
        }

        this.first = first;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Factories
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Getters And Setters
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Methods
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public boolean merge( EventManager that )
    {
        return this.merge( that.first );
    }

    public boolean merge( Entry entry )
    {
        if( entry == null ) return false;

        final boolean hasSameId = this.first.getId().equals( entry.getId() );
        if( hasSameId )
        {
            this.second = entry;
        }
        return hasSameId;
    }

    public boolean isComplete()
    {
        return this.second != null;
    }

    public Event getEvent()
    {
        return getEvent( DEFAULT_EVENT_ALERT_IN_MILLI_SECS );
    }

    public Event getEvent( int eventAlertInMilliSecs )
    {
        final String id = first.getId();
        final int duration = calculateDuration();
        final String type = first.getType();
        final String host = first.getHost();
        return new Event( id, duration, type, host, duration > eventAlertInMilliSecs );
    }

    private int calculateDuration()
    {
        if( second == null ) return 0;

        // no sure if the entry state (STARTED or FINISHED) should follow the timestamp
        // here we allow a negative timestamp because we are comparing states and not timestamps directly
        return ( int ) ( first.getState().equals( EntryState.STARTED )
                ? second.getTimestamp() - first.getTimestamp()
                : first.getTimestamp() - second.getTimestamp() );
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Inner Classes And Patterns
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}
